<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Samoussa Runner - WAYOWAYO</title>
    <style>
        * {
            box-sizing: border-box;
            touch-action: manipulation;
        }
        
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f5f5f5;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            height: 100vh;
            max-height: 500px;
            overflow: hidden;
            border: 3px solid #333;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            background-color: #87CEEB;
        }
        
        /* Div dédié au fond défilant pour éviter les saccades */
        #scrolling-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 200%;
            height: 100%;
            background-image: url('assets/kitchen_bg.png');
            background-repeat: repeat-x;
            background-size: auto 100%;
            will-change: transform;
            backface-visibility: hidden;
            transform: translateZ(0);
            animation: scrollBg 20s linear infinite;
        }
        
        @keyframes scrollBg {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }

        #ground {
            position: absolute;
            width: 100%;
            height: 15%;
            bottom: 0;
            background-color: rgba(141, 110, 99, 0.7);
            z-index: 2;
        }

        #samoussa {
            position: absolute;
            width: 18%;  /* Augmenté significativement pour mobile */
            max-width: 100px;
            aspect-ratio: 1/1;
            bottom: 15%;
            left: 15%;
            z-index: 5;
            /* Style pour l'élément visuel */
            background-image: url('assets/samoussa_run1.png');
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
        }
        
        /* Hitbox pour le samoussa */
        #samoussa::after {
            content: '';
            position: absolute;
            width: 70%;
            height: 70%;
            top: 15%;
            left: 15%;
            border-radius: 35%;
            background-color: rgba(0, 0, 0, 0);
            z-index: -1;
        }

        .obstacle {
            position: absolute;
            width: 16%;  /* Augmenté significativement pour mobile */
            max-width: 80px;
            aspect-ratio: 1/1;
            bottom: 15%;
            z-index: 4;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
        }

        .obstacle.couteau {
            background-image: url('assets/couteau.png');
        }
        
        .obstacle.couteau::after {
            content: '';
            position: absolute;
            width: 60%;
            height: 70%;
            top: 15%;
            left: 20%;
            clip-path: polygon(0% 20%, 50% 100%, 100% 20%, 80% 0%, 20% 0%);
            background-color: rgba(0, 0, 0, 0);
            z-index: -1;
        }

        .obstacle.marmite {
            background-image: url('assets/marmite.png');
        }
        
        .obstacle.marmite::after {
            content: '';
            position: absolute;
            width: 80%;
            height: 80%;
            top: 15%;
            left: 10%;
            border-radius: 50% 50% 20% 20%;
            background-color: rgba(0, 0, 0, 0);
            z-index: -1;
        }

        .obstacle.main {
            background-image: url('assets/main.png');
        }
        
        .obstacle.main::after {
            content: '';
            position: absolute;
            width: 70%;
            height: 90%;
            top: 5%;
            left: 15%;
            border-radius: 30% 30% 10% 10%;
            background-color: rgba(0, 0, 0, 0);
            z-index: -1;
        }

        .collectible {
            position: absolute;
            width: 14%;  /* Augmenté significativement pour mobile */
            max-width: 60px;
            aspect-ratio: 1/1;
            z-index: 4;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
        }

        .collectible.piment {
            background-image: url('assets/piment.png');
        }
        
        .collectible.piment::after {
            content: '';
            position: absolute;
            width: 70%;
            height: 70%;
            top: 15%;
            left: 15%;
            border-radius: 50% 15% 50% 15%;
            transform: rotate(45deg);
            background-color: rgba(0, 0, 0, 0);
            z-index: -1;
        }

        .collectible.epice {
            background-image: url('assets/epice.png');
        }
        
        .collectible.epice::after {
            content: '';
            position: absolute;
            width: 60%;
            height: 60%;
            top: 20%;
            left: 20%;
            border-radius: 10px;
            background-color: rgba(0, 0, 0, 0);
            z-index: -1;
        }

        .collectible.biere {
            background-image: url('assets/biere_dodo.png');
            aspect-ratio: 5/6;
        }
        
        .collectible.biere::after {
            content: '';
            position: absolute;
            width: 70%;
            height: 80%;
            top: 10%;
            left: 15%;
            border-radius: 20% 20% 5% 5%;
            background-color: rgba(0, 0, 0, 0);
            z-index: -1;
        }

        /* Fallbacks en cas de problème de chargement */
        .fallback-mode #scrolling-bg {
            background-image: none;
            background-color: #87CEEB;
        }
        
        .fallback-mode #samoussa {
            background-image: none;
            background-color: #f3c669;
            border-radius: 35%;
        }
        
        .fallback-mode .obstacle.couteau {
            background-image: none;
            background-color: #a1a1a1;
            clip-path: polygon(0% 20%, 50% 100%, 100% 20%, 80% 0%, 20% 0%);
        }
        
        .fallback-mode .obstacle.marmite {
            background-image: none;
            background-color: #505050;
            border-radius: 50% 50% 10% 10%;
        }
        
        .fallback-mode .obstacle.main {
            background-image: none;
            background-color: #ffcba4;
            border-radius: 30% 30% 10% 10%;
        }
        
        .fallback-mode .collectible.piment {
            background-image: none;
            background-color: #ff3b30;
            border-radius: 50% 15% 50% 15%;
            transform: rotate(45deg);
        }
        
        .fallback-mode .collectible.epice {
            background-image: none;
            background-color: #ff9500;
            border-radius: 5px;
        }
        
        .fallback-mode .collectible.biere {
            background-image: none;
            background-color: #ffd700;
            border-radius: 20% 20% 5% 5%;
        }

        #score-container {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 4vmin;
            font-weight: bold;
            z-index: 10;
        }

        .status-effect {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(255, 165, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 4vmin;
            font-weight: bold;
            z-index: 10;
            display: none;
        }

        .overlay-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 1000;
            text-align: center;
        }

        #logo {
            font-size: 8vmin;
            font-weight: bold;
            margin-bottom: 20px;
            color: #ff6b6b;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .btn {
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 5vmin;
            background-color: #ff6b6b;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 2000;
            position: relative;
        }

        .btn:hover, .btn:active {
            background-color: #ff8c8c;
            transform: scale(1.05);
        }

        .restaurant-info {
            width: 100%;
            font-size: 3vmin;
            color: white;
            text-align: center;
            margin-top: 30px;
        }

        .invisible {
            opacity: 0.5;
        }
        
        .power-indicator {
            position: absolute;
            bottom: 8%;
            left: 50%;
            transform: translateX(-50%);
            height: 10px;
            width: 50%;
            background-color: #333;
            border-radius: 5px;
            overflow: hidden;
            z-index: 10;
        }
        
        .power-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4CAF50, #FFC107, #F44336);
            transition: width 0.1s;
        }
        
        #combo-container {
            position: absolute;
            top: 60px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.6);
            padding: 10px;
            border-radius: 5px;
            font-size: 4vmin;
            font-weight: bold;
            color: #ff6b6b;
            z-index: 10;
            display: none;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        .combo-pulse {
            animation: pulse 0.5s ease-in-out;
        }
        
        .collect-effect {
            position: absolute;
            color: #FFEB3B;
            font-weight: bold;
            font-size: 4vmin;
            z-index: 5;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            transition: transform 0.5s, opacity 0.5s;
        }
        
        #highscores {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 35%;
            max-width: 200px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 3vmin;
            z-index: 10;
        }
        
        #highscores h3 {
            margin: 0 0 10px 0;
            text-align: center;
            color: #ff6b6b;
            font-size: 3.5vmin;
        }
        
        #highscores ol {
            margin: 0;
            padding-left: 25px;
        }
        
        #highscores li {
            margin-bottom: 5px;
        }
        
        .share-buttons {
            display: flex;
            justify-content: center;
            margin-top: 20px;
            gap: 10px;
        }
        
        .share-button {
            display: inline-block;
            padding: 8px 12px;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            font-size: 3vmin;
        }
        
        .share-facebook {
            background-color: #4267B2;
        }
        
        .share-twitter {
            background-color: #1DA1F2;
        }
        
        .share-whatsapp {
            background-color: #25D366;
        }
        
        /* Effet de boost amélioré */
        .boost-effect {
            position: absolute;
            width: 150px;
            height: 60px;
            background: radial-gradient(ellipse at center, rgba(255, 165, 0, 0.7), rgba(255, 165, 0, 0) 70%);
            border-radius: 50%;
            z-index: 2;
            pointer-events: none;
            display: none;
            transform: translateX(-50%);
            animation: boost-pulse 0.8s infinite alternate;
        }
        
        @keyframes boost-pulse {
            0% { transform: translateX(-50%) scale(1); opacity: 0.7; }
            100% { transform: translateX(-50%) scale(1.2); opacity: 0.5; }
        }
        
        .overlay-screen > * {
            max-width: 90%;
            margin-left: auto;
            margin-right: auto;
        }
        
        #instructions {
            font-size: 3.5vmin;
        }
        
        #jump-hint {
            position: absolute;
            bottom: 25%;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 5px;
            font-size: 3.5vmin;
            z-index: 20;
            display: none;
            text-align: center;
        }
        
        @media (orientation: landscape) {
            #game-container {
                height: 85vh;
                max-height: 500px;
            }
        }
        
        @media (max-height: 500px) {
            .restaurant-info {
                font-size: 2.5vmin;
                margin-top: 15px;
            }
            
            .btn {
                padding: 10px 20px;
                font-size: 4vmin;
                margin-top: 10px;
            }
        }
        
        /* Ajouter une classe de debug pour visualiser les hitboxes */
        .debug-mode .obstacle::after,
        .debug-mode .collectible::after,
        .debug-mode #samoussa::after {
            background-color: rgba(255, 0, 0, 0.5) !important;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="scrolling-bg"></div>
        <div id="ground"></div>
        <div id="samoussa"></div>
        <div id="score-container">Score: <span id="score">0</span></div>
        <div id="combo-container">Combo: <span id="combo-count">x1</span></div>
        <div class="status-effect" id="invisibility-effect">Invisibilité: <span id="invisibility-time">0</span>s</div>
        <div class="boost-effect" id="boost-effect"></div>
        
        <!-- Tableau des meilleurs scores -->
        <div id="highscores">
            <h3>Meilleurs scores</h3>
            <ol id="highscore-list">
                <li>---</li>
                <li>---</li>
                <li>---</li>
                <li>---</li>
                <li>---</li>
            </ol>
        </div>
        
        <!-- Indicateur de saut pour appareils tactiles -->
        <div id="jump-hint">Tapez pour sauter !</div>
    </div>
    
    <!-- Écrans détachés -->
    <div id="start-screen" class="overlay-screen">
        <div id="logo">WAYOWAYO</div>
        <h2>Samoussa Runner</h2>
        <p>Aidez le samoussa à éviter les obstacles et à collecter les épices!</p>
        <div id="instructions">
            <p>Sur mobile: <strong>Tapez sur l'écran</strong> pour sauter</p>
            <p>Sur ordinateur: <strong>ESPACE</strong> pour sauter</p>
            <p>Maintenez appuyé pour sauter plus haut!</p>
        </div>
        <button class="btn" id="start-button">JOUER</button>
        <div class="restaurant-info">
            <p>Restaurant Créole Réunionnais WAYOWAYO</p>
            <p>Venez déguster nos délicieux samoussas!</p>
        </div>
    </div>
    
    <div id="game-over" class="overlay-screen" style="display: none;">
        <h2>GAME OVER</h2>
        <p>Score final: <span id="final-score">0</span></p>
        <p>Meilleur combo: <span id="final-combo">x1</span></p>
        
        <!-- Boutons de partage -->
        <div class="share-buttons">
            <div class="share-button share-facebook" onclick="shareScore('facebook')">Facebook</div>
            <div class="share-button share-twitter" onclick="shareScore('twitter')">Twitter</div>
            <div class="share-button share-whatsapp" onclick="shareScore('whatsapp')">WhatsApp</div>
        </div>
        
        <button class="btn" id="restart-button">REJOUER</button>
        <div class="restaurant-info">
            <p>Restaurant Créole Réunionnais WAYOWAYO</p>
            <p>Venez déguster nos délicieux samoussas!</p>
        </div>
    </div>

    <script>
        // Détection du type d'appareil
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Éléments du DOM
        const gameContainer = document.getElementById('game-container');
        const samoussa = document.getElementById('samoussa');
        const scoreElement = document.getElementById('score');
        const finalScoreElement = document.getElementById('final-score');
        const gameOverScreen = document.getElementById('game-over');
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const invisibilityEffect = document.getElementById('invisibility-effect');
        const invisibilityTime = document.getElementById('invisibility-time');
        const jumpHint = document.getElementById('jump-hint');
        const boostEffect = document.getElementById('boost-effect');
        const scrollingBg = document.getElementById('scrolling-bg');

        // Gestion des assets et fallback
        function checkImagesLoaded() {
            const testImage = new Image();
            testImage.src = 'assets/samoussa_run1.png';
            testImage.onload = function() {
                console.log("Images chargées correctement");
            };
            testImage.onerror = function() {
                console.log("Impossible de charger les images, passage en mode fallback");
                document.body.classList.add('fallback-mode');
            };
        }
        
        // Vérifier si les images sont chargées
        checkImagesLoaded();

        // Variables du jeu
        let isJumping = false;
        let isGameOver = true;
        let isGameStarted = false;
        let isInvisible = false;
        let invisibilityTimer = 0;
        let invisibilityDuration = 5;
        let score = 0;
        let gameSpeed = 3;
        let maxGameSpeed = 7;
        let difficultyLevel = 1;
        let minObstacleDistance = 350;
        let lastObstaclePosition = 0;
        let gameTime = 0;
        let gameContainerWidth = gameContainer.clientWidth;
        
        // Variables pour le système de combo
        let comboMultiplier = 1;
        let comboCount = 0;
        let maxCombo = 1;
        let lastCollectTime = 0;
        const comboDuration = 3000;
        
        // Récupérer les meilleurs scores depuis le localStorage
        let highScores = [];
        try {
            const savedScores = localStorage.getItem('wayowayoHighScores');
            if (savedScores) {
                highScores = JSON.parse(savedScores);
            } else {
                highScores = [0, 0, 0, 0, 0];
            }
        } catch (e) {
            console.error("Erreur lors de la récupération des scores:", e);
            highScores = [0, 0, 0, 0, 0];
        }
        
        // Variables du saut basé sur la pression
        let isSpacePressed = false;
        let isTouching = false;
        let touchStartTime = 0;
        let spacePressStartTime = 0;
        let maxPressTime = 800;
        let minJumpPower = 0.3;
        let jumpPower = minJumpPower;
        let powerIndicator = null;

        // Variables de saut
        let jumpTime = 0;
        let jumpDuration = 65;
        let jumpHeight = 150;
        let initialSamoussaBottom;
        let lastJumpTime = 0;
        let jumpAnimationId = null;
        
        // Variables pour gérer le timing entre les frames
        let lastFrameTime = 0;
        const targetFPS = 60;
        const frameInterval = 1000 / targetFPS;

        // Images pour les animations
        const samoussaImages = {
            run1: 'assets/samoussa_run1.png',
            run2: 'assets/samoussa_run2.png',
            crash: 'assets/samoussa_crash.png'
        };
        
        // Types d'obstacles et de collectibles
        const obstacleTypes = ['couteau', 'marmite', 'main'];
        const collectibleTypes = ['piment', 'epice', 'biere'];
        let currentFrame = 0;
        
        // Tableaux pour stocker les éléments du jeu
        let obstacles = [];
        let collectibles = [];
        
        // Planification des éléments
        let nextObstacleTime = 3000;
        let nextCollectibleTime = 2000;
        
        // Adaptation mobile vs desktop
        if (isMobile) {
            // Afficher l'indice de saut pour mobile
            jumpHint.style.display = 'block';
            // Paramètres spécifiques au mobile
            maxPressTime = 500; // Plus court sur mobile
            
            // Ajuster la vitesse du jeu légèrement pour mobile
            gameSpeed = 2.7; // Un peu plus lent sur mobile
        }

        // Créer l'indicateur de puissance
        function createPowerIndicator() {
            powerIndicator = document.createElement('div');
            powerIndicator.className = 'power-indicator';
            powerIndicator.style.display = 'none';
            
            const powerBar = document.createElement('div');
            powerBar.className = 'power-bar';
            powerIndicator.appendChild(powerBar);
            
            gameContainer.appendChild(powerIndicator);
        }

        // S'assurer que l'écran de démarrage est visible au début
        startScreen.style.display = 'flex';
        samoussa.style.display = 'block';
        
        // Créer l'indicateur de puissance
        createPowerIndicator();
        
        // Fonction pour adapter les tailles en fonction de la taille de l'écran
        function resizeGame() {
            gameContainerWidth = gameContainer.clientWidth;
            const groundHeight = gameContainer.clientHeight * 0.15;
            initialSamoussaBottom = groundHeight;
            
            // Mettre à jour la taille/position du samoussa
            samoussa.style.bottom = groundHeight + 'px';
            
            // Recalculer les obstacles
            obstacles.forEach(obstacle => {
                obstacle.element.style.bottom = groundHeight + 'px';
            });
            
            // Adapter les valeurs de saut en fonction de la taille
            jumpHeight = gameContainer.clientHeight * 0.4;
        }
        
        // Appeler resize au chargement et au redimensionnement
        window.addEventListener('load', resizeGame);
        window.addEventListener('resize', resizeGame);

        // Événements pour clavier
        document.addEventListener('keydown', function(event) {
            // Démarrer le jeu avec la touche Entrée
            if ((event.code === 'Enter' || event.key === 'Enter') && !isGameStarted) {
                startGame();
                return;
            }
            
            // Commencer à charger le saut quand on appuie sur espace
            if ((event.code === 'Space' || event.key === ' ') && !isJumping && !isGameOver && isGameStarted && !isSpacePressed) {
                isSpacePressed = true;
                spacePressStartTime = Date.now();
                jumpPower = minJumpPower;
                
                // Commencer l'animation de charge
                startJumpCharge();
            }
        });
        
        document.addEventListener('keyup', function(event) {
            // Sauter quand on relâche la barre d'espace
            if ((event.code === 'Space' || event.key === ' ') && isSpacePressed && !isGameOver && isGameStarted) {
                const pressDuration = Date.now() - spacePressStartTime;
                const normalizedDuration = Math.min(pressDuration / maxPressTime, 1.0);
                
                // Calculer la puissance entre min et max
                jumpPower = minJumpPower + (1 - minJumpPower) * normalizedDuration;
                
                // Cacher l'indicateur de puissance
                if (powerIndicator) {
                    powerIndicator.style.display = 'none';
                }
                
                isSpacePressed = false;
                jump();
            }
        });
        
        // Événements tactiles pour mobile
        gameContainer.addEventListener('touchstart', function(event) {
            event.preventDefault(); // Empêcher le zoom/scroll
            
            // Si le jeu est déjà démarré, démarrer le chargement du saut
            if (isGameStarted && !isGameOver && !isJumping && !isTouching) {
                isTouching = true;
                touchStartTime = Date.now();
                jumpPower = minJumpPower;
                
                // Commencer l'animation de charge
                startJumpCharge();
                
                // Cacher l'indice après le premier saut
                jumpHint.style.display = 'none';
            }
        }, { passive: false });

        gameContainer.addEventListener('touchend', function(event) {
            // Sauter quand on relâche
            if (isTouching && !isGameOver && isGameStarted) {
                const pressDuration = Date.now() - touchStartTime;
                const normalizedDuration = Math.min(pressDuration / maxPressTime, 1.0);
                
                // Calculer la puissance entre min et max
                jumpPower = minJumpPower + (1 - minJumpPower) * normalizedDuration;
                
                // Cacher l'indicateur de puissance
                if (powerIndicator) {
                    powerIndicator.style.display = 'none';
                }
                
                isTouching = false;
                jump();
            }
        });
        
        // Empêcher le défilement de la page sur mobile
        document.addEventListener('touchmove', function(event) {
            if (isGameStarted && !isGameOver) {
                event.preventDefault();
            }
        }, { passive: false });
        
        // Clic dans le conteneur du jeu
        gameContainer.addEventListener('click', function(event) {
            // Si le jeu est déjà démarré, permettre de sauter en cliquant
            if (isGameStarted && !isGameOver && !isElementClicked(event.target, [startButton, restartButton])) {
                // Pour les clics simples, saut à 80% de puissance
                jumpPower = 0.8;
                jump();
                
                // Cacher l'indice après le premier saut
                jumpHint.style.display = 'none';
            }
        });

        // Démarrer le jeu avec un clic sur le bouton Jouer
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', restartGame);
        
        // Ajouter des événements tactiles spécifiques pour les boutons de l'écran de game over
        restartButton.addEventListener('touchstart', function(event) {
            event.preventDefault();
            restartGame();
        });
        
        // Partage tactile
        document.querySelectorAll('.share-button').forEach(button => {
            button.addEventListener('touchstart', function(event) {
                event.preventDefault();
                const platform = this.classList.contains('share-facebook') ? 'facebook' : 
                                 this.classList.contains('share-twitter') ? 'twitter' : 'whatsapp';
                shareScore(platform);
            });
        });

        // Vérifier si un élément cliqué est dans une liste d'éléments
        function isElementClicked(element, elementList) {
            return elementList.some(el => el === element || el.contains(element));
        }

        // Animation de chargement du saut avec indicateur visuel
        function startJumpCharge() {
            if ((!isSpacePressed && !isTouching) || isJumping || isGameOver) return;
            
            // Animer le samoussa pour indiquer le chargement
            const currentTime = Date.now();
            const pressStart = isSpacePressed ? spacePressStartTime : touchStartTime;
            const progress = Math.min((currentTime - pressStart) / maxPressTime, 1.0);
            
            // Actualiser la puissance du saut
            jumpPower = minJumpPower + ((1 - minJumpPower) * progress);
            
            // Mettre à jour l'indicateur visuel de puissance
            if (powerIndicator) {
                powerIndicator.style.display = 'block';
                const powerBar = powerIndicator.querySelector('.power-bar');
                if (powerBar) {
                    powerBar.style.width = `${progress * 100}%`;
                }
            }
            
            // Animation visuelle de chargement - compression puis extension
            if (progress < 0.5) {
                // Phase de compression
                const scale = 1 - (progress * 0.25);
                samoussa.style.transform = `scale(${scale}, ${1 + progress * 0.25})`;
            } else {
                // Phase de préparation avec effet de pulsation
                const bounce = Math.sin((progress - 0.5) * 6 * Math.PI) * 0.05;
                samoussa.style.transform = `scale(${0.85 + bounce}, ${1.15 - bounce})`;
            }
            
            // Continuer l'animation tant que la touche/écran est pressée
            if (isSpacePressed || isTouching) {
                requestAnimationFrame(startJumpCharge);
            } else {
                // Cacher l'indicateur quand on relâche
                if (powerIndicator) {
                    powerIndicator.style.display = 'none';
                }
            }
        }

        // Fonction de saut améliorée
        function jump() {
            if (isJumping || isGameOver) return;
            
            // Réinitialiser en cas de problème
            if (jumpAnimationId) {
                cancelAnimationFrame(jumpAnimationId);
                jumpAnimationId = null;
            }
            
            isJumping = true;
            jumpTime = 0;
            lastJumpTime = 0;
            
            // Position initiale du samoussa
            const initialBottom = parseInt(window.getComputedStyle(samoussa).getPropertyValue('bottom'));
            
            // Éliminer toute transition précédente
            samoussa.style.transition = "";
            
            // Appliquer la puissance du saut aux paramètres
            const actualJumpHeight = jumpHeight * jumpPower;
            
            // Système de rafraîchissement adaptatif
            let previousProgress = 0;
            
            function updateJump(timestamp) {
                if (isGameOver) {
                    isJumping = false;
                    jumpAnimationId = null;
                    return;
                }
                
                if (!lastJumpTime) lastJumpTime = timestamp;
                const deltaTime = timestamp - lastJumpTime;
                
                // Contrôle plus fin pour animations rapides
                if (deltaTime < 8) {
                    jumpAnimationId = requestAnimationFrame(updateJump);
                    return;
                }
                
                jumpTime += deltaTime / 16;
                lastJumpTime = timestamp;
                
                // Animation visuelle de déplacement
                const jumpProgress = Math.min(jumpTime / jumpDuration, 1.0);
                
                // Hauteur de saut parabolique
                const verticalPosition = Math.sin(jumpProgress * Math.PI) * actualJumpHeight + initialBottom;
                
                // Position horizontale fixe
                samoussa.style.bottom = verticalPosition + 'px';
                
                // Illusion de mouvement horizontal par transformation CSS
                let visualOffset = 0;
                if (jumpProgress < 0.5) {
                    // Mouvement visuel vers l'avant jusqu'à 50% du saut
                    visualOffset = jumpProgress * 50;
                } else {
                    // Retour progressif à la position neutre
                    visualOffset = (1 - jumpProgress) * 50;
                }
                
                // Rotation combinée avec translation pour effet de mouvement
                let rotationAngle = 0;
                if (jumpProgress < 0.3) {
                    rotationAngle = 15;
                } else if (jumpProgress < 0.7) {
                    rotationAngle = 0;
                } else {
                    rotationAngle = -10;
                }
                
                // Appliquer la transformation combinée
                samoussa.style.transform = `rotate(${rotationAngle}deg) translateX(${visualOffset}px)`;
                
                // Fin anticipée du saut pour permettre un enchaînement plus rapide
                if (previousProgress > 0.8 && jumpProgress >= 0.98) {
                    finishJump();
                    return;
                }
                
                previousProgress = jumpProgress;
                
                // Continuer le saut jusqu'à la fin
                if (jumpProgress < 1.0) {
                    jumpAnimationId = requestAnimationFrame(updateJump);
                } else {
                    finishJump();
                }
            }
            
            // Fonction séparée pour terminer le saut proprement
            function finishJump() {
                isJumping = false;
                jumpAnimationId = null;
                
                // Retour à la position de repos sans effet visuel
                samoussa.style.bottom = initialSamoussaBottom + 'px';
                samoussa.style.transform = 'rotate(0deg)';
            }
            
            jumpAnimationId = requestAnimationFrame(updateJump);
        }

        // Fonction pour démarrer le jeu
        function startGame() {
            console.log("Démarrage du jeu");
            startScreen.style.display = 'none';
            isGameOver = false;
            isGameStarted = true;
            isInvisible = false;
            invisibilityTimer = 0;
            score = 0;
            gameTime = 0;
            
            // Réinitialiser le système de combo
            comboMultiplier = 1;
            comboCount = 0;
            maxCombo = 1;
            document.getElementById('combo-container').style.display = 'none';
            document.getElementById('combo-count').textContent = 'x1';
            
            // Mettre à jour l'affichage
            scoreElement.textContent = score;
            lastObstaclePosition = 0;
            nextObstacleTime = 3000;
            nextCollectibleTime = 2000;
            
            // Masquer le tableau des scores pendant le jeu
            document.getElementById('highscores').style.display = 'none';
            
            // Si c'est mobile, montrer l'indice de saut
            if (isMobile) {
                jumpHint.style.display = 'block';
                // Le cacher après 3 secondes
                setTimeout(() => {
                    jumpHint.style.display = 'none';
                }, 3000);
            }
            
            // Réinitialiser la position du samoussa
            samoussa.style.bottom = initialSamoussaBottom + 'px';
            samoussa.style.transform = 'rotate(0deg)';
            samoussa.style.backgroundImage = `url(${samoussaImages.run1})`;
            samoussa.classList.remove('invisible');
            invisibilityEffect.style.display = 'none';
            
            // Supprimer tous les obstacles et collectibles existants
            clearElements();
            
            // Intervalles pour le jeu
            const gameInterval = setInterval(() => {
                // Mettre à jour le temps de jeu
                gameTime += 100;
                
                // Générer les obstacles
                if (gameTime >= nextObstacleTime) {
                    createObstacle();
                    // Prochain obstacle avec délai variable basé sur la difficulté
                    const minDelay = Math.max(1000, 1800 - ((difficultyLevel - 1) * 100));
                    const maxAdditionalDelay = Math.max(500, 1500 - ((difficultyLevel - 1) * 150));
                    nextObstacleTime = gameTime + minDelay + Math.random() * maxAdditionalDelay;
                }
                
                // Générer les collectibles
                if (gameTime >= nextCollectibleTime) {
                    createSafeCollectible();
                    // Prochain collectible avec délai variable
                    const minDelay = 3000;
                    const maxAdditionalDelay = 2000;
                    nextCollectibleTime = gameTime + minDelay + Math.random() * maxAdditionalDelay;
                }
                
                // Vérifier si le combo doit être réinitialisé (temps écoulé depuis la dernière collecte)
                if (comboCount > 0 && Date.now() - lastCollectTime > comboDuration) {
                    resetCombo();
                }
            }, 100);
            
            // Intervalles pour l'animation et le score
            const scoreInterval = setInterval(updateScore, 100);
            const animationInterval = setInterval(animateSamoussa, 200);
            const effectsInterval = setInterval(updateEffects, 1000);
            
            // Stocker les intervalles pour pouvoir les arrêter plus tard
            window.gameIntervals = {
                game: gameInterval,
                score: scoreInterval,
                animation: animationInterval,
                effects: effectsInterval
            };
            
            // Réinitialiser le timer pour l'animation
            lastFrameTime = 0;
            
            // Démarrer l'animation du jeu
            requestAnimationFrame(updateGame);
        }

        // Fonction pour redémarrer le jeu
        function restartGame() {
            gameOverScreen.style.display = 'none';
            
            // Réinitialiser les variables
            isJumping = false;
            isSpacePressed = false;
            isTouching = false;
            jumpTime = 0;
            
            // Redémarrer le jeu après une courte pause
            setTimeout(() => {
                startGame();
            }, 100);
        }

        // Nettoyer les éléments existants
        function clearElements() {
            obstacles.forEach(obstacle => {
                if (obstacle.element && obstacle.element.parentNode) {
                    obstacle.element.remove();
                }
            });
            collectibles.forEach(collectible => {
                if (collectible.element && collectible.element.parentNode) {
                    collectible.element.remove();
                }
            });
            obstacles = [];
            collectibles = [];
        }

        // Animer le samoussa
        function animateSamoussa() {
            if (isGameOver || isJumping) return;
            
            currentFrame = (currentFrame + 1) % 2;
            
            // Alterner entre les deux images de course
            if (!document.body.classList.contains('fallback-mode')) {
                if (currentFrame === 0) {
                    samoussa.style.backgroundImage = `url(${samoussaImages.run1})`;
                } else {
                    samoussa.style.backgroundImage = `url(${samoussaImages.run2})`;
                }
            }
        }

        // Fonction pour créer un obstacle
        function createObstacle() {
            if (isGameOver) return;
            
            // Vérifier la distance avec le dernier obstacle
            const rightmostObstacle = obstacles.reduce((maxPos, obstacle) => 
                Math.max(maxPos, obstacle.position), 0);
            
            const adjustedDistance = minObstacleDistance * (gameContainerWidth / 800);
            
            if (rightmostObstacle > gameContainerWidth - adjustedDistance) {
                return;
            }
            
            // À des niveaux plus élevés, possibilité d'obstacles doubles
            let createDouble = false;
            if (difficultyLevel >= 4 && Math.random() < 0.25) {
                createDouble = true;
            }
            
            // Créer le premier obstacle
            const obstacle = document.createElement('div');
            obstacle.classList.add('obstacle');
            
            // Type d'obstacle aléatoire
            const obstacleType = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
            obstacle.classList.add(obstacleType);
            
            // Position initiale à droite de l'écran
            obstacle.style.left = gameContainerWidth + 'px';
            obstacle.style.bottom = initialSamoussaBottom + 'px';
            gameContainer.appendChild(obstacle);
            
            obstacles.push({
                element: obstacle,
                position: gameContainerWidth,
                type: obstacleType
            });
            
            lastObstaclePosition = gameContainerWidth;
            
            // Créer un deuxième obstacle si nécessaire
            if (createDouble && difficultyLevel >= 4) {
                setTimeout(() => {
                    if (isGameOver) return;
                    
                    const obstacle2 = document.createElement('div');
                    obstacle2.classList.add('obstacle');
                    
                    // Type différent pour le second obstacle
                    let obstacleType2;
                    do {
                        obstacleType2 = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                    } while (obstacleType2 === obstacleType && obstacleTypes.length > 1);
                    
                    obstacle2.classList.add(obstacleType2);
                    
                    // Espacement réduit avec la difficulté
                    const spacingFactor = gameContainerWidth / 800;
                    const spacing = Math.max(170 * spacingFactor, 200 * spacingFactor - ((difficultyLevel - 4) * 10 * spacingFactor));
                    obstacle2.style.left = (gameContainerWidth + spacing) + 'px';
                    obstacle2.style.bottom = initialSamoussaBottom + 'px';
                    
                    // Obstacle surélevé aux niveaux avancés
                    if (difficultyLevel >= 7 && Math.random() < 0.3) {
                        const heightOffset = 20 + Math.random() * 40;
                        obstacle2.style.bottom = (initialSamoussaBottom + heightOffset) + 'px';
                    }
                    
                    gameContainer.appendChild(obstacle2);
                    
                    obstacles.push({
                        element: obstacle2,
                        position: gameContainerWidth + spacing,
                        type: obstacleType2
                    });
                    
                    lastObstaclePosition = gameContainerWidth + spacing;
                }, 100);
            }
        }

        // Fonction pour créer un collectible accessible et sans collision avec les obstacles
        function createSafeCollectible() {
            if (isGameOver) return;
            
            const collectible = document.createElement('div');
            collectible.classList.add('collectible');
            
            // Type de collectible aléatoire
            const collectibleType = collectibleTypes[Math.floor(Math.random() * collectibleTypes.length)];
            collectible.classList.add(collectibleType);
            
            // Position toujours à droite de l'écran
            let positionX = gameContainerWidth;
            collectible.style.left = positionX + 'px';
            
            // Récupérer tous les obstacles existants pour vérifier les collisions
            const allObstacles = obstacles.map(o => ({
                x: o.position,
                y: parseInt(o.element.style.bottom) || initialSamoussaBottom,
                width: parseInt(window.getComputedStyle(o.element).width),
                height: parseInt(window.getComputedStyle(o.element).height)
            }));
            
            // Tentatives de placement sans collision
            let attempts = 0;
            let validPosition = false;
            let positionY = 0;
            
            while (!validPosition && attempts < 20) {
                attempts++;
                
                // Déterminer une position verticale de base
                const gameHeight = gameContainer.clientHeight;
                if (Math.random() < 0.7) {
                    // 70% du temps en hauteur
                    positionY = Math.random() * (gameHeight * 0.3) + (initialSamoussaBottom + 30);
                } else {
                    // 30% du temps près du sol
                    positionY = Math.random() * 30 + (initialSamoussaBottom + 10);
                }
                
                // Vérifier la distance avec tous les obstacles
                let tooClose = false;
                
                for (const obstacle of allObstacles) {
                    // Distance horizontale
                    const horizontalDistance = Math.abs(positionX - obstacle.x);
                    
                    // Distance verticale
                    const collectibleHeight = (collectibleType === 'biere') ? 60 : 50;
                    const verticalOverlap = (positionY < obstacle.y + obstacle.height) && 
                                           (positionY + collectibleHeight > obstacle.y);
                    
                    // Si trop proche horizontalement et en chevauchement vertical
                    if (horizontalDistance < 100 && verticalOverlap) {
                        tooClose = true;
                        break;
                    }
                }
                
                // Si position valide (pas trop proche d'obstacles)
                if (!tooClose) {
                    validPosition = true;
                } else {
                    // Ajuster la position X pour éviter les obstacles
                    positionX += 50 + Math.random() * 50;
                }
            }
            
            // Si après 20 tentatives toujours pas de position valide, placer loin
            if (!validPosition) {
                positionX = gameContainerWidth + 200 + Math.random() * 200;
                positionY = Math.random() * (gameContainer.clientHeight * 0.3) + (initialSamoussaBottom + 30);
            }
            
            // Appliquer les positions
            collectible.style.left = positionX + 'px';
            collectible.style.bottom = positionY + 'px';
            
            gameContainer.appendChild(collectible);
            
            collectibles.push({
                element: collectible,
                position: positionX,
                bottom: positionY,
                type: collectibleType
            });
        }

        // Fonction pour vérifier les collisions avec des hitboxes précises
        function checkCollision(element1, element2) {
            // Version améliorée qui utilise les pseudoéléments ::after comme hitbox
            const rect1 = element1.getBoundingClientRect();
            const rect2 = element2.getBoundingClientRect();
            
            // Taille relative de la hitbox par rapport à l'élément parent
            // Ces valeurs correspondent aux pourcentages dans le CSS
            const hitbox1 = {
                width: rect1.width * 0.7, 
                height: rect1.height * 0.7,
                left: rect1.left + rect1.width * 0.15,
                top: rect1.top + rect1.height * 0.15
            };
            
            // Déterminer la taille de hitbox en fonction du type d'élément
            let hitbox2;
            if (element2.classList.contains('couteau')) {
                hitbox2 = {
                    width: rect2.width * 0.6,
                    height: rect2.height * 0.7,
                    left: rect2.left + rect2.width * 0.2,
                    top: rect2.top + rect2.height * 0.15
                };
            } else if (element2.classList.contains('marmite')) {
                hitbox2 = {
                    width: rect2.width * 0.8,
                    height: rect2.height * 0.8,
                    left: rect2.left + rect2.width * 0.1,
                    top: rect2.top + rect2.height * 0.15
                };
            } else if (element2.classList.contains('main')) {
                hitbox2 = {
                    width: rect2.width * 0.7,
                    height: rect2.height * 0.9,
                    left: rect2.left + rect2.width * 0.15,
                    top: rect2.top + rect2.height * 0.05
                };
            } else if (element2.classList.contains('collectible')) {
                hitbox2 = {
                    width: rect2.width * 0.7,
                    height: rect2.height * 0.7,
                    left: rect2.left + rect2.width * 0.15,
                    top: rect2.top + rect2.height * 0.15
                };
            } else {
                // Hitbox par défaut
                hitbox2 = {
                    width: rect2.width,
                    height: rect2.height,
                    left: rect2.left,
                    top: rect2.top
                };
            }
            
            // Vérifier si les hitboxes se chevauchent
            return !(
                hitbox1.left + hitbox1.width < hitbox2.left ||
                hitbox1.left > hitbox2.left + hitbox2.width ||
                hitbox1.top + hitbox1.height < hitbox2.top ||
                hitbox1.top > hitbox2.top + hitbox2.height
            );
        }

        // Mettre à jour le score et la difficulté
        function updateScore() {
            if (isGameOver) return;
            
            score += 1;
            scoreElement.textContent = score;
            
            // Paliers de difficulté
            const difficultyThresholds = [
                { score: 300, speed: isMobile ? 3.2 : 3.5, distance: 330, level: 2 },
                { score: 600, speed: isMobile ? 3.7 : 4.0, distance: 300, level: 3 },
                { score: 1000, speed: isMobile ? 4.2 : 4.5, distance: 280, level: 4 },
                { score: 1500, speed: isMobile ? 4.7 : 5.0, distance: 260, level: 5 },
                { score: 2000, speed: isMobile ? 5.2 : 5.5, distance: 240, level: 6 },
                { score: 2500, speed: isMobile ? 5.7 : 6.0, distance: 220, level: 7 },
                { score: 3000, speed: isMobile ? 6.2 : 6.5, distance: 200, level: 8 },
                { score: 4000, speed: isMobile ? 6.7 : 7.0, distance: 180, level: 9 }
            ];
            
            // Augmenter la difficulté selon le score
            for (const threshold of difficultyThresholds) {
                if (score >= threshold.score && difficultyLevel < threshold.level) {
                    gameSpeed = threshold.speed;
                    minObstacleDistance = threshold.distance;
                    difficultyLevel = threshold.level;
                    
                    // Notification de changement de niveau
                    const levelUpNotice = document.createElement('div');
                    levelUpNotice.style.position = 'absolute';
                    levelUpNotice.style.top = '50%';
                    levelUpNotice.style.left = '50%';
                    levelUpNotice.style.transform = 'translate(-50%, -50%)';
                    levelUpNotice.style.color = '#FF5722';
                    levelUpNotice.style.fontWeight = 'bold';
                    levelUpNotice.style.fontSize = '28px';
                    levelUpNotice.style.textShadow = '2px 2px 4px rgba(0,0,0,0.5)';
                    levelUpNotice.style.zIndex = '50';
                    levelUpNotice.textContent = `Niveau ${threshold.level}!`;
                    
                    gameContainer.appendChild(levelUpNotice);
                    
                    // Animation de fondu
                    let opacity = 1;
                    const fadeOut = setInterval(() => {
                        opacity -= 0.05;
                        levelUpNotice.style.opacity = opacity;
                        
                        if (opacity <= 0) {
                            clearInterval(fadeOut);
                            if (levelUpNotice.parentNode) {
                                levelUpNotice.remove();
                            }
                        }
                    }, 50);
                    
                    break;
                }
            }
        }

        // Mettre à jour les effets actifs
        function updateEffects() {
            if (isGameOver) return;
            
            // Gestion de l'invisibilité
            if (isInvisible) {
                invisibilityTimer--;
                invisibilityTime.textContent = invisibilityTimer;
                
                if (invisibilityTimer <= 0) {
                    isInvisible = false;
                    samoussa.classList.remove('invisible');
                    invisibilityEffect.style.display = 'none';
                }
            }
        }

        // Activer l'effet d'invisibilité
        function activateInvisibility() {
            isInvisible = true;
            invisibilityTimer = invisibilityDuration;
            invisibilityTime.textContent = invisibilityTimer;
            samoussa.classList.add('invisible');
            invisibilityEffect.style.display = 'block';
        }

        // Effet boost amélioré quand on prend la bière
        function showBoostEffect() {
            // Positionner l'effet sous le samoussa
            const samoussaRect = samoussa.getBoundingClientRect();
            const centerX = samoussaRect.left + (samoussaRect.width / 2);
            
            boostEffect.style.display = 'block';
            boostEffect.style.left = centerX + 'px';
            boostEffect.style.bottom = samoussa.style.bottom;
            
            // Arrêter toute animation précédente
            if (window.boostAnimation) {
                clearTimeout(window.boostAnimation);
            }
            
            // Garder l'effet visible pendant 1 seconde
            window.boostAnimation = setTimeout(() => {
                boostEffect.style.display = 'none';
            }, 1000);
        }

        // Mettre à jour le jeu à chaque frame
        function updateGame(timestamp) {
            if (isGameOver) return;
            
            // Gestion du temps entre les frames
            if (!lastFrameTime) lastFrameTime = timestamp;
            const deltaTime = timestamp - lastFrameTime;
            
            // Limiter la fréquence pour une vitesse constante
            if (deltaTime < frameInterval) {
                requestAnimationFrame(updateGame);
                return;
            }
            
            // Facteur de mouvement basé sur le temps écoulé
            const speedFactor = deltaTime / frameInterval;
            const moveAmount = gameSpeed * speedFactor;
            
            lastFrameTime = timestamp;
            
            // Déplacer les obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                obstacle.position -= moveAmount;
                obstacle.element.style.left = obstacle.position + 'px';
                
                // Supprimer les obstacles hors écran
                if (obstacle.position < -60) {
                    obstacle.element.remove();
                    obstacles.splice(i, 1);
                    continue;
                }
                
                // Vérifier les collisions si pas invisible
                if (!isInvisible) {
                    if (checkCollision(samoussa, obstacle.element)) {
                        gameOver();
                        return;
                    }
                }
            }
            
            // Déplacer les collectibles
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const collectible = collectibles[i];
                collectible.position -= moveAmount;
                collectible.element.style.left = collectible.position + 'px';
                
                // Supprimer les collectibles hors écran
                if (collectible.position < -50) {
                    collectible.element.remove();
                    collectibles.splice(i, 1);
                    continue;
                }
                
                // Vérifier les collisions
                if (checkCollision(samoussa, collectible.element)) {
                    // Incrémenter le combo
                    incrementCombo();
                    lastCollectTime = Date.now();
                    
                    // Points de base selon le type
                    let basePoints = 10;
                    
                    // Effet selon le type de collectible
                    if (collectible.type === 'biere') {
                        activateInvisibility();
                        basePoints = 20;
                        showBoostEffect();
                        
                        // Vibration sur mobile si supporté
                        if (isMobile && navigator.vibrate) {
                            navigator.vibrate(100);
                        }
                    } else if (collectible.type === 'piment') {
                        basePoints = 15;
                    }
                    
                    // Appliquer le multiplicateur de combo
                    const pointsGained = basePoints * comboMultiplier;
                    score += pointsGained;
                    
                    scoreElement.textContent = score;
                    collectible.element.remove();
                    collectibles.splice(i, 1);
                    
                    // Animation de collecte améliorée
                    const collectEffect = document.createElement('div');
                    collectEffect.className = 'collect-effect';
                    collectEffect.style.left = collectible.position + 'px';
                    collectEffect.style.bottom = collectible.bottom + 'px';
                    
                    // Message selon le type et combo
                    if (collectible.type === 'biere') {
                        collectEffect.textContent = `+${pointsGained} INVISIBLE!`;
                        collectEffect.style.color = '#FF9800';
                    } else if (collectible.type === 'piment') {
                        collectEffect.textContent = `+${pointsGained}`;
                        collectEffect.style.color = '#F44336';
                    } else {
                        collectEffect.textContent = `+${pointsGained}`;
                    }
                    
                    // Faire grossir l'effet en fonction du combo
                    if (comboMultiplier > 1) {
                        collectEffect.style.fontSize = (4 + (comboMultiplier * 0.5)) + 'vmin';
                    }
                    
                    gameContainer.appendChild(collectEffect);
                    
                    // Animation de flottement et disparition
                    setTimeout(() => {
                        collectEffect.style.transform = 'translateY(-50px)';
                        collectEffect.style.opacity = '0';
                    }, 50);
                    
                    setTimeout(() => {
                        if (collectEffect.parentNode) {
                            collectEffect.remove();
                        }
                    }, 1000);
                }
            }
            
            requestAnimationFrame(updateGame);
        }

        // Fonction pour terminer le jeu
        function gameOver() {
            isGameOver = true;
            isJumping = false;
            isSpacePressed = false;
            isTouching = false;
            
            // Cacher l'indicateur de puissance
            if (powerIndicator) {
                powerIndicator.style.display = 'none';
            }
            
            // Cacher l'indice de saut
            jumpHint.style.display = 'none';
            
            // Masquer le conteneur de combo
            document.getElementById('combo-container').style.display = 'none';
            
            // Mettre à jour et afficher le tableau des meilleurs scores
            updateHighScores();
            document.getElementById('highscores').style.display = 'block';
            
            // Annuler l'animation de saut
            if (jumpAnimationId) {
                cancelAnimationFrame(jumpAnimationId);
                jumpAnimationId = null;
            }
            
            // Arrêter tous les intervalles
            if (window.gameIntervals) {
                Object.values(window.gameIntervals).forEach(interval => {
                    clearInterval(interval);
                });
            }
            
            // Animation de crash
            if (!document.body.classList.contains('fallback-mode')) {
                samoussa.style.backgroundImage = `url(${samoussaImages.crash})`;
            }
            samoussa.style.transform = 'rotate(45deg)';
            
            // Vibration sur mobile si supporté
            if (isMobile && navigator.vibrate) {
                navigator.vibrate([100, 50, 200]);
            }
            
            // Mettre à jour les scores finaux
            finalScoreElement.textContent = score;
            document.getElementById('final-combo').textContent = `x${maxCombo}`;
            
            setTimeout(() => {
                gameOverScreen.style.display = 'flex';
            }, 500);
        }
        
        // Fonction pour mettre à jour les meilleurs scores
        function updateHighScores() {
            // Ajouter le score actuel à la liste
            highScores.push(score);
            
            // Trier par ordre décroissant
            highScores.sort((a, b) => b - a);
            
            // Garder seulement les 5 meilleurs
            highScores = highScores.slice(0, 5);
            
            // Sauvegarder dans le localStorage
            try {
                localStorage.setItem('wayowayoHighScores', JSON.stringify(highScores));
            } catch (e) {
                console.error("Erreur lors de la sauvegarde des scores:", e);
            }
            
            // Mettre à jour l'affichage
            const highscoreList = document.getElementById('highscore-list');
            highscoreList.innerHTML = '';
            
            highScores.forEach(highScore => {
                const li = document.createElement('li');
                
                // Mettre en évidence le score actuel s'il fait partie des meilleurs
                if (highScore === score && score > 0) {
                    li.style.fontWeight = 'bold';
                    li.style.color = '#ff6b6b';
                }
                
                li.textContent = highScore;
                highscoreList.appendChild(li);
            });
        }
        
        // Fonction pour partager le score sur les réseaux sociaux
        function shareScore(platform) {
            const shareText = `Je viens de faire ${score} points dans Samoussa Runner sur le site du restaurant WAYOWAYO! Mon meilleur combo: x${maxCombo}. Venez battre mon record!`;
            let shareUrl = '';
            
            switch(platform) {
                case 'facebook':
                    shareUrl = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(window.location.href)}&quote=${encodeURIComponent(shareText)}`;
                    break;
                case 'twitter':
                    shareUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(shareText)}&url=${encodeURIComponent(window.location.href)}`;
                    break;
                case 'whatsapp':
                    shareUrl = `https://wa.me/?text=${encodeURIComponent(shareText + ' ' + window.location.href)}`;
                    break;
            }
            
            if (shareUrl) {
                window.open(shareUrl, '_blank');
            }
        }
        
        // Système de combo
        function incrementCombo() {
            comboCount++;
            comboMultiplier = Math.min(comboCount + 1, 5); // Maximum x5 multiplicateur
            
            // Mettre à jour l'affichage du combo
            const comboContainer = document.getElementById('combo-container');
            const comboCountElement = document.getElementById('combo-count');
            
            comboContainer.style.display = 'block';
            comboCountElement.textContent = `x${comboMultiplier}`;
            
            // Effet visuel de pulsation
            comboContainer.classList.remove('combo-pulse');
            void comboContainer.offsetWidth; // Force reflow
            comboContainer.classList.add('combo-pulse');
            
            // Mettre à jour le combo maximum
            if (comboMultiplier > maxCombo) {
                maxCombo = comboMultiplier;
            }
        }
        
        function resetCombo() {
            comboCount = 0;
            comboMultiplier = 1;
            
            // Masquer l'affichage du combo
            document.getElementById('combo-container').style.display = 'none';
        }
        
        // Désactiver le double-tap qui pourrait causer un zoom sur mobile
        document.addEventListener('touchend', function(e) {
            if (isGameStarted) {
                e.preventDefault();
            }
        }, { passive: false });
    </script>
</body>
</html>
